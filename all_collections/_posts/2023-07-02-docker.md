---
layout: post
title: 🚢 Docker 컨테이너 기술의 핵심
date: 2023-07-02
categories: ["SamBeak", "Docker", "Container", "가상화"]
---

# Docker란 무엇이며 컨테이너란 무엇인가

<br>
개발을 공부하다 보면 여기저기 Docker라는 단어에 대해 보게 된다. <br>
자바와 파이썬을 공부하다보니 자연스럽게 관심이 생기고 의문이 생기게 된 Docker에 대해 본격적으로 공부하고 정리하고자 글을 작성한다. <br><br>

> 애플리케이션

본격적으로 시작하기 앞서, 애플리케이션은 개발 중인 프로그램이나 서비스를 의미한다.

> Docker란 무엇인가 ?

Docker는 컨테이너화 기술을 기반으로 한 오픈 소스 플랫폼이다. <br>
컨테이너는 애플리케이션이 동작하는데 필요한 모든 소프트웨어와 종속성을 포함한 독립적 실행 환경이다. <br><br>
Docker를 사용하면 컨테이너로 애플리케이션을 패키징하고, <br>
이런 컨테이너를 호스트 시스템에서 동일한 방식으로 실행할 수 있게 된다. <br>
그러나 앞서 언급한 것처럼 컨테이너는 애플리케이션을 위한 독립적 실행 환경이기 때문에 <br>
격리되어 있고, 호스트 시스템의 변화에는 영향을 받지 않는다. 즉, 호스트 시스템과 상관 없이 일관성 있게 작동하게 된다. <br>
이는 개발 환경과 운영 환경 사이의 차이를 줄이고, 애플리케이션의 이식성과 확장성을 향상 시킬 수 있도록 만든다. <br><br>

Docker 컨테이너가 호스트 시스템의 변화에 영향을 받지 않는 것은 격리 된 환경때문이다. <br>
Docker는 리눅스 커널의 네임스페이스 기능을 사용해 컨테이너의 프로세스, 네트워크, 파일 시스템 등을 격리시킨다. <br>
그렇기에 각 컨테이너는 독립된 네임스페이스를 갖고, 호스트 시스템이나 다른 컨테이너에서 실행 중인 프로세스와 격리되는 것이다. <br>
또한, Docker는 컨트롤 그룹 기능을 사용하여 각 컨테이너에 리소스 제한을 설정하기도 한다. 이는 리소스를 공정하게 분배하고 <br>
특정 컨테이너가 다른 컨테이너에 영향을 미치지 않도록 만든다. <br>
Docker 컨테이너는 각 컨테이너가 독립된 파일 시스템을 갖고 있고, 호스트 시스템의 파일과는 분리되어 있다. <br>
이를 통해 컨테이너 간 파일 시스템 충돌을 방지학도, 각 컨테이너가 독립적으로 파일을 수정하고 관리하도록한다. <br>
마지막으로, Docker는 가상 네트워크를 사용하여 컨테이너 간의 통신을 관리한다. <br>
각 컨테이너는 독립된 IP 주소를 갖는데, 이는 호스트 시스템 및 다른 컨테이너와 격리된 네트워크를 형성한다. <br>
그렇기에 컨테이너 간의 네트워크 충돌 혹은 간섭은 방지할 수 있고 보안도 강화할 수 있는 것이다. <br><br>

계속되어 언급되는 호스트 시스템은 Docker를 실행하기 위해 기반이 되는 운영 체제와 하드웨어를 의미한다. <br>
쉽게 말하면 Docker 사용자의 기반 시스템을 의미한다. <br>
컨테이너는 이러한 호스트 시스템 위에서 동작하지만 호스트 시스템과는 독립적으로 실행할 수 있다. <br><br>

Docker의 핵심 개념은 이미지, 컨테이너 그리고 레지스트리다. 물론 더 공부해야할 것이 많아보이지만... 개론으로..<br><br>

> 이미지는 애플리케이션과 그걸 실행하기 위해 필요한 모든 구성 요소, 종속성을 패키징한 것을 의미한다. <br>
> 읽기 전용이고, 컨테이너를 생성하는데 사용된다. 이미지는 Dockerfile이란 text파일에 의해 정의되며 Docker 명령을 사용해 빌드할 수 있다. <br><br>

> 컨테이너는 이미지의 인스턴스이다. 컨테이너는 앞서 수차례 언급처럼 호스트 시스템과 독립되어있고, 다른 컨테이너와도 분리되어 작동한다. <br><br>

> 레지스트리는 Docker 이미지를 저장하고 관리하는 중앙 저장소를 의미한다. 가장 잘 알려진 레지스트리는 Docker Hub이고, <br>
> 공개 이미지와 개인 이미지를 저장할 수 있으며 독립적인 레지스트리도 구축해 사용할 수 있다.

# Docker 장점과 이점

<br>
Docker는 개발과 배포에 있어 상당히 혁신적으로 접근한다. <br>
앞서 Docker 컨테이너가 호스트 시스템과 격리되어 있기에 애플리케이션의 이식성과 확장성을 향상 시킬 수 있도록 한다고 언급했다. <br>
컨테이너가 애플리케이션과 그 종속성을 패키징하는 완전한 실행 환경이기 때문에 컨테이너는 다른 환경으로 쉽게 이동하거나 배포하는게 가능해진다. <br>
로컬 개발 환경에서 개발한 애플리케이션을 동일한 컨테이너를 사용해 프로덕션 환경으로 이동할 수 있고, 이 때 호스트 시스템 변화에 영향은 거의 받지 않는다. <br>
> 이것을 이식성(Potability)라고 한다. 내가 개발한 애플리케이션이 내 컴퓨터 시스템에서만 사용할 것이 아니지 않은가. <br><br>

Docker는 컨테이너를 쉽게 복제하고 확장할 수 있도록 그 기능을 제공한다. <br>
여러 개의 동일한 컨테이너 인스턴스를 실행해 애플리케이션의 부하를 줄일 수 있다. <br>

> 이러한 확장성(Scalability)은 수평적인 확장성을 갖는 애플리케이션 아키텍처를 구축할 수 있게 만든다. <br><br>

DOcker 컨테이너는 격리된 실행 환경을 통해 각 컨테이너가 자체 파일 시스템, 네트워크, 프로세스 공간을 갖도록 하고, <br>

> 호스트 시스템 및 다른 컨테이너와 격리(Isolation)되어 작동하도록 한다. <br>

이를 통해 애플리케이션 간의 충동을 방지하고 보안은 강화하며, 의존성 충돌은 최소화한다. <br><br>

Docker는 인프라스트럭처를 코드로 관리하는 개념인 "인프라스트럭처 지원"을 적용할 수 있다. <br>
Dockerfile을 사용해 애플리케이션의 구성을 정의하고, Docker Compose를 사용해 여러 컨테이너로 구성된 애플리케이션 스택을 정의할 수 있다. <br>
즉, 반복 가능하고 자동화된 방식으로 애플리케이션을 구성하고 배포할 수 있도록 만든다. <br>

> 이러한 빠른 구성(Configuration)은 Docker의 장점이자 이점이다. <br>

> 결국 Docker는 개발자가 일관된 환경에서 개발하고 운영팀은 쉽게 확장 가능한 아키텍처를 구축하도록 돕는다.
> 이는 개발과 배포 사이 간극을 줄이고, 협업과 전달 속도를 향상시킨다는 것이 가장 큰 이점이다. <br>

# Docker 설치와 설정

<br>

```
1. Docker 설치 : 공홈 설치
필자는 macOS라 homebrew 사용 , brew install docker , brew install docker-compose
2. Docker Daemon 실행
win, macOs : Docker Desktop 실행 시 자동 실행
linux : sudo systemctl start docker
3. 사용자 권한 설정 : 현재 사용자를 Docker 그룹에 추가, 추가 후 재로그인
사용자 그룹 추가 : sudo usermod-aG docker 사용자이름
4. Docker 확인 : docker version
docker run hello-world 통해 작동 확인
```

| 설정           | 내용                                             |
| -------------- | ------------------------------------------------ |
| docker build   | Dockerfile 작성 후 사용, 이미지 빌드             |
| docker run     | 컨테이너 실행                                    |
| docker stop    | 컨테이너 중지                                    |
| docker ps      | 컨테이너 목록 조회                               |
| -v / --mount   | 볼륨 마운트                                      |
| -p / --publish | 포트 매핑                                        |
| -v / --env     | 환경 변수 설정                                   |
| --restart      | 재시작 정책 설정, 재시작 조건, 횟수 제한 등 설정 |

- 볼륨 마운트 : 호스트 파일 시스템 디텍토리를 컨테이너 경로에 마운트
- 포트 매핑 : 포트 매핑을 사용해 컨테이너 내부 포트를 호스트의 포트에 매핑, 컨테이너 애플리케이션에 외부 접근 가능
- 환경 변수 설정 : 환경 변수를 사용해 컨테이너 내부 설정 지정, 이를 통해 애플리케이션의 구성을 유연하게 관리 및 설정 조정
- Docker Compose : 다중 컨테이너 관리다.
- CI/CD 파이프라인 통합 : Continuos Integration/ Continuos Deployment로 <br>
  Docker이미지로 애플리케이션 빌드, 테스트 후 이미지를 레지스트리에 푸시하여 배포하는 단계에서 사용한다. <br>
  Jenkins, GitLab CICD, CircleCI는 Docker를 사용한 파이프라인을 제공한다.
- 네트워크 설정 : Docker는 기본적으로 컨테이너 간 네트워크 통신을 지원, 여러 컨테이너가 동일 네트워크에 있을 때 서로 통신 가능 <br>
- 로깅 설정(Logging) : Docker는 컨테이너의 로그를 수집, 관리하는 로깅 드라이버를 제공한다. <br>
  로그 드라이버를 설정해 컨테이너의 로그를 중앙 집중식 로그 시스템에 전송하거나 파일로 저장 가능하다.<br>
  Prometheus, Grafana, ELK 스택이 대표적 로깅 및 모니터링 도구다.
- 자동 재시작(Automatic Restart) : 컨테이너가 비정상 종료됐을 때, 자동으로 재시작

# 가상화 개념: Docker 이미지와 컨테이너

<br>
Docker 이미지는 애플리케이션이 실행하는데 필요한 모든 구성 요소와 종속성을 패키징한 것이라고 언급했다. <br>
보통 이미지는 한 개의 레어이가 아닌 여러 개의 레이어로 구성되는데, 각 레이어는 애플리케이션의 특정 부분을 나타낸다. <br>
Ubuntu 레이어, 종속성 레이어, 코드 레이어 등이 그 예다. <br>
Docker 이미지는 여러 개의 레이어들을 계층적으로 쌓아서 구성된다.<br>
이미지는 컨테이너의 기반이 되고, Docker Hub 같은 레지스트리에서 공유된다. <br><br>
컨테이너는 이미지의 인스턴스이다. 흔히 인스턴스는 추상적 개념인 클래스에서 생성된 객체를 의미한다. <br>
각 컨테이너는 고유한 파일 시스템, 네트워크, 프로세스 공간 등을 가지고 호스트 시스템과 분리되어 실행된다. <br>
컨테이너는 이미지를 기반으로 실행되는데, 컨테이너를 실행할 때 이미지의 레이어가 읽기 전용으로 마운트되고 <br>
컨테이너의 변경 사항은 컨테이너 내부에 저장되게 된다. <br><br>
Docker 컨테이너가 독립적인 환경을 제공한다는 것은 가상 머신과 비슷한 가상화 개념으로 이해할 수 있다. <br>
> 다른 점은 Docker는 전체 운영 체제를 가상화하지 않고 호스트 시스템의 거널은 공유하며 격리된 프로세스 공간을 제공하는 <br>
경량화 된 가상화 방식이라는 점이다. <br>
경량화 된 가상화 방식은 컨테이너가 가볍고 빠르게 실행되게 하고, 호스트 시스템과의 상호 작용을 용이하게 한다. <br><br>

# 애플리케이션 배포 : Dockerfile을 사용하여 커스텀 이미지 생성

<br>
> 1. Dockerfile 작성 : 원하는 이미지 선택 후 Dockerfile 작성한다. <br>
> 명령문 + 지시어 / 애플리케이션의 종류와 요구 사항에 맞게 구성한다. <br>
> 2. 기본 이미지 선택 : Dockerfile에서 FROM 지시어를 사용해 기본 이미지 선택 <br>
> 기본 이미지는 애플리케이션을 실행하기 위해 필요한 운영체제와 소프트웨어 환경을 제공한다. <br>
> 3. 애플리케이션 종속성 설치 : RUN 지시어 사용 <br>
> 패키지 관리자나 기타 설치 도구를 사용하여 필요한 소프트웨어를 설치하거나 의존성을 해결한다. <br>
> 4. 애플리케이션 파일 복사 : COPY 지시어 사용 <br>
> 로컬 파일 시스템 -> Docker 이미지로 복사 / 애플리케이션의 소스 코드, 설정 파일 등이 이미지 내부로 포함 <br>
> 5. 포트 노출 : EXPOSE 지시어 사용 <br>
> 외부에서 해당 포트로 컨테이너에 접근토록 설정 <br>
> 6. 실행 명령 설정 : CMD 또는 ENTRYPOINT 지시어 사용 <br>
> 컨테이너가 시작될 때 실행되는 명령을 설정 / 애플리케이션 실행 명령이 지정되고 실행 환경을 구성 <br>
> 7. Docker 이미지 빌드 : Dockerfile을 사용해 커스텀 이미지 빌드, docker buid 명령 사용 <br>
> Dockerfile 기반으로 이미지 생성하고 태그 지정 <br>
> 8. 컨테이너 실행 : docker run 명령 사용 <br>
> 커스텀 이미지를 사용해 컨테이너를 실행하고 애플리케이션 배포 <br>

# 애플리케이션 스택 관리 간소화 : Docker Compose 다중 컨테이너 환경 구축

<br>
Docker Compose는 여러 개의 컨테이너로 구성된 애플리케이션을 관리하기 위한 도구다. <br>
Compose는 주로 다중 컨테이너 환경을 간편하게 구축하고, 애플리케이션 스택을 관리하는데 사용한다. <br>
개발자의 입장에선 자칫 복잡해질 수 있는 여러 개의 컨테이너를 간단한 명령어를 통해 애플리케이션을 실행하고, 관리하며 확장 할 수 있다. <br><br>

> 다중 컨테이너 환경 구축<br>

- 단일 파일화(YAML)
  Docker Compose는 YAML 파일로 애플리케이션의 서비스, 네트워크, 볼륨, 환경 변수 등을 구성하는데, <br>
  YAML 파일에는 각 컨테이너의 구성이나 종속성을 명시 할 수 있다. 이를 통해 애플리케이션을 단일 파일로 구성하고, <br>
  이 파일들을 통해서 다중 컨테이너 환경을 구축할 수 있게 만든다. <br><br>
- 네트워크 연결 (Network)
  Docker Compose는 각 컨테이너 간에 네트워크 연결을 설정하는 기능을 제공하는데, <br>
  컨테이너 간의 통신을 위해 가상 네트워크를 자동으로 생성하고 컨테이너 간의 서비스 발견을 용이하게 만든다. <br>
  이러한 기능은 다중 컨테이너 애플리케이션의 구성이나 관리를 간편하게 만든다. <br><br>
- 확장과 조정
  Docker Compose는 동일한 Compose 파일을 기반으로 여러 인스턴스의 컨테이너를 실행할 수 있고, <br>
  컨테이너의 개수를 조정해서 애플리케이션의 부하에 따라 확장할 수 있다. <br>
- 개발 환경과 운영 환경의 일치화
  또한, Docker Compose는 개발 환경과 운영 환경을 일치시킬 수도 있는데, <br>
  개발 환경에서 사용하는 Compose 파일을 운영 환경에서도 동일하게 사용해 애플리케이션을 배포할 수 있다. <br>
  이러한 기능은 개발과 운영 사이의 차이를 최소화시키고 애플리케이션 배포 과정을 표준화시킬 수 있다. <br><br>

# Docker Networking : 컨테이너 간 통신, 외부 연결 설정

<br>
Docker에서는 컨테이너 간의 통신이나 외부랑 연결을 위해서 네트워킹 기능을 제공한다. <br>
컨테이너 간 통신은 내부적으로 도커 네트워크를 사용해서 이루어지고, 외부랑 연결은 포트 매핑을 통해 이뤄진다. <br><br>

> Docker 네트워크

Docker는 기본적으로 컨테이너 간 가상 네트워크를 생성해 통신할 수 있게 한다. <br>
이 가상 네트워크는 Docker 브릿지 네트워크라고 불리고, Docker 엔진에 의해 자동 생성된다. <br>
동일한 Docker 호스트에서 실행 중인 컨테이너는 해당 네트워크에 연결되어 P 주소 혹은 컨테이너 이름으로 서로 통신할 수 있다. <br>

> 포트 매핑

컨테이너를 외부로 노출하고 싶을 때는 포트 매핑을 사용한다. <br>
Docker 컨테이너는 호스트 머신의 포트와 컨테이너의 포트를 연결시켜주는 기능을 제공하는데, <br>
이런 기능은 외부에서 호스트 머신의 IP 주소와 해당 포트로 접속해 해당컨테이너의 서비스에 접근할 수 있도록 한다. <br>
위 테이블 표기처럼 포트 매핑은 -p / --publish 명령어를 사용해 설정 가능하다. <br>

> 예시

```
docker run -p 80:80 <imgName>
```

위 예시는 호스트 머신의 80번 포트와 컨테이너의 80번 포트가 연결되어 <br>
외부에서 호스트 머신의 IP 주소와 80번포트로 해당 컨테이너의 웹 서버에 접근할 수 있도록한다. <br><br>

# Docker와 클라우드 : 오케스트레이션과 서비스 배포

<br>
Docker와 클라우드는 컨테이너 오케스트레이션과 서비스 배포를 지원한다. <br>
* 컨테이너 오케스트레이션
컨테이너 오케스트레이션은 여러 개의 컨테이너를 자동으로 관리하고 조율하는 프로세스를 의미한다. <br>
오케스트레이션은 컨테이너의 배포, 확장, 로드밸런싱, 장애 복구 등을 효율적으로 처리하는데 사용할 수 있다. <br>
대표 툴로 Kubernetes, Docker Swarm, Apache Mesos가 있다. <br><br>
* 서비스 배포
Docker와 클라우드의 조합은 애플리케이션의 서비스 배포를 단순화할 수 있다. <br>
클라우드 플랫폼은 Docker 컨테이너를 쉽게 배포하고 관리할 수 있는 환경을 제공하고, <br>
이를 통해 개발자는 컨테이너 이미지를 클라우드 플랫폼에 업로드하고, 필요한 리소스를 할당하며, 배포를 자동화할 수 있다. <br>
클라우드 기반의 서비스 배포는 확장성이 높고 유영선을 제공하며, 애플리케이션을 신속하게 확장하거나 축소하는데 도움을 준다. <br><br>

# Docker 보안과 모니터링 : 주요 고려 사항

<br>
> 보안

컨테이너 이미는 신뢰할 수 있는 소스에서 가져오고, 공식 이미지나 신뢰 가능한 레지스트리에서 활용해야한다. <br>
이미지의 취약점을 보안하도록 주기적 업데이트를 해야하고 보안 패치를 적용해야한다. <br>
컨테이너 간의 격리는 가능한 유지해 다른 컨테이너에 침범하지 않도록 해야한다. <br>
컨테이너 실행 시엔 항상 필요한 최소한의 권한만을 부여하고 호스트와 공유도 최소호 해야한다. <br>
SELinux나 AppArmor, seccomp 프로파일을 설정하는 것도 추가 보안을 적용하는 방법이다. <br><br>

> 모니터링

컨테이너의 로그를 중앙 집중화하고 모니터링해서 애플리케이션이나 시스템의 문제를 파악해야한다. <br>
이를 위해 로깅 분석 도구나 분석 시스템을 활용할 수 있다. <br>
컨테이너의 자원 사용량 예를 들어, CPUU, 메모리, 디스크, 네트워크 등을 모니터링하고 성능 이슈를 식별해야한다. <br>
성능을 추적하고 성능에 따라 적절한 조치를 취하기 위함이다. <br>
컨테이너나 호스트 시스템에서 보안 이벤트를 모니터링해 악용 시도를 탐지하고 대응해야한다. <br>
IDS(침입감지시스템) 나 IPS(침입방지시스템), 취약점 스캐너등을 사용하는 것도 방법이다. <br><br>

# 지속적 통합 및 배포 프로세스에 통합 : CI/CD

<br>
CI는 Continuos Integration로 지속적인 통합을 의미하고, <br>
CD는 Continuos Deployment로 지속적인 배포를 의미한다. <br>
즉, CI/CD 파이프라인은 개발자가 소프트웨어를 지속적으로 통합, 빌드, 테스트, 배포하기 위해 자동화시킨 프로세스이다. <br><br>
Docker를 CI/CD 프로세스에 통합하는 것은 일관된 환경을 제공하고 빠른 빌드, 배포를 가능하게 하며, <br>
컨테이너에 확장성과 탄력성을 제공해 트래픽 변동에 유연하게 대응할 수 있도록 만든다. <br>
또한, 환경 복원과 롤백을 보다 효율적으로 할 수 있도록 하는 것 또한 통합의 이점이다. <br><br>

CI/CD 파이프라인에서 Docker를 사용하면 개발, 테스트, 배포 단계 간에 일관된 환경을 유지할 수 있게 한다. <br>
모든 단계에서 동일한 컨테이너 이미지를 사용하므로 환경 차이로 인한 문제는 줄일 수 있고 배포의 일관성은 보장할 수 있다. <br><br>
CI/CD 파이프라인에서 Docker를 사용하면 애플리케이션의 빌드 및 테스트 시간 또한 단축할 수 있는데, <br>
이미지 빌드 및 배포 단계를 병렬로 실행하거나 동시에 수행할 수 있어 전체 프로세스 속도를 향상시킬 수 있다. <br><br>
CI/CD 파이프라인에서 Docker를 사용하면 필요한 만큼의 컨테이너 인스턴스를 생성해 병렬로 테스트하거나 스케일 아웃할 수 있다. <br>
이는 높은 확장성과 유연성을 제공해 트래픽 변동에 유연하게 대응할 수 있게 만든다. <br><br>
본래 Docker 이지는 애플리케이션 및 환경의 버전 관리를 용이하게 한다. <br>
CI/CD 파이프라인에서 Docker를 사용하면 특정 버전의 이미지를 사용하여 배포 환경을 쉽게 복원하거나 롤백할 수 있다. <br><br>
